# Содержимое папок

/bin – содержит стандартные утилиты Linux. Или по другому этот каталог содержит основные исполняемые файлы (в Windows такие файлы имеют расширение .exe), доступные всем пользователям, а также содержит символьные ссылки на исполняемые файлы. Символьная ссылка это специальный файл в файловой системе, внутри которого есть только одна-две строки с указанием полного пути, который должен быть открыт при попытке обратиться к данной ссылке (файлу).

    cd /bin

Исполняемые файлы хранятся в /bin – минимальный набор исполн.. файлов, которые нужны для работы системы, /usr/bin – расширен.набор(мб на другом носителе), /usr/local/bin – …
Opt – дополнительно
В /lib* - минимальный набор , /usr/lib



/boot – содержит конфигурационные файлы загрузчика GRUB, образы ядра (по умолчанию хранятся последние три), файлы Initrd. Чтобы было понятно, что это за такие мифические файлы Initrd, немного внесем ясность. Когда начинается начальная загрузка системы, сначала монтируется временный виртуальный диск, который содержит временную корневую файловую систему, с помощью которой, в свою очередь, осуществляется запуск ядра Linux. Файл Initrd - образ этой временной корневой системы, который хранится на загрузочном устройстве.

      cd /boot
      
/dev – содержит файлы устройств. В Linux устройством называется оборудование, которое подключается к системе в процессе загрузки ядра или в процессе работы системы. Эти устройства представляют методы для ввода или вывода информации. Например, жесткий диск – устройство для ввода (запись) и вывода (чтение), мышь – устройство ввода. Каждое движение или нажатие на кнопки мыши отправляет символ на устройство /dev/mouse, клавиатура – тоже устройство ввода. Большинство устройств в Linux представляют из себя файлы в особой файловой системе (исключение составляют сетевые карты). И вот эти файлы хранятся в каталоге /dev, куда к ним обращается система для выполнения задач, связанных с вводом/выводом.
      
      cd /dev
     
/proc - это не совсем обычный каталог, это каталог псевдофайловой системы procfs, которая используется для предоставления информации о процессах (по-другому это виртуальная файловая система, которая обеспечивает связь с ядром и монтируется в каталогу /proc). Да-да, в системе Linux присутствует виртуальный файловый объект, именуемый каталогом /proc. Он существует только во время работы системы в оперативной памяти компьютера. Каталог представляет интерес и с точки зрения безопасности. Многие из утилит, выводящие информацию о системе (например, команда ps), берут свои исходные данные именно из этого каталога.

    cd /proc
    
/run – это совершенно новый каталог, который появился совсем недавно. И создан он (по задумке разработчиков) для хранения данных, которые были запущены приложениями, требующимися в процессе работы (это могут быть и службы, запускаемые самой системой, и программы, которые Вы запускаете сами).
    
    cd /run
    
/usr – содержит пользовательские программы, документацию, исходные коды программ и ядра. По размеру это один из самых больших каталогов файловой системы. В этот каталог устанавливаются практически все программы. И его (этот каталог) с большой натяжкой можно сравнить с каталогом Program Files в Windows.

    cd /usr
    
/etc - Этот каталог содержит файлы настроек: всё, от конфигурационных файлов системы X Window, базы данных пользователей и до стартовых сценариев.
    
    cd /etc
    
# Несколько стандартных утилит

### Cut

Команда cut выделяет столбцы текста (части строк) из каждого ФАЙЛА и отправляет в стандартный поток вывода. Столбец определяется либо по смещению в символах 
Например, четвёртое поле в каждой строке файла, которые отделены друг от друга запятыми (разделители - запятые):
        
        cut -d, -f4 myfile
        
 Или пробел
            
         cut -d' ' -f4 myfile
       
Примеры:

        cat test
    sdbfhbsdfb sdnj fb sbhd bf
    sdfnk nsdj  dsjfj sj
     sdlf mnksdn k
     
И применяем команду:

            cat test | cut -d' ' -f1
            sdbfhbsdfb
            sdfnk
  
 ### Head 
    
Печатает первые 10 строк каждого ФАЙЛА на стандартный вывод. Если задано несколько ФАЙЛОВ, сначала печатает заголовок с именем файла. Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

Флаг -n -> количество вместо 10

Пример:
        
        cat test | head
        sdbfhbsdfb sdnj fb sbhd bf
        sdfnk nsdj  dsjfj sj
        sdlf mnksdn ksdf ,lsd
        f
        dsf'
        sdf

        sd
C флагом -n

        cat test | head -n 5
        sdbfhbsdfb sdnj fb sbhd bf
        sdfnk nsdj  dsjfj sj
        sdlf mnksdn ksdf ,lsd
        f   
    
 ### Tail
 
 Печатает последние 10 строк каждого из ФАЙЛОВ на стандартный вывод. Если задано несколько ФАЙЛОВ, сначала печатается заголовок с именем файла. Если ФАЙЛ не задан или задан как /-, читает стандартный ввод.

Флаг -n -> количество вместо 10

Пример:

        cat test | tail
        fdf
        g
        ree

        re

        e
        s
        d

        
C флагом -n

    cat test | tail -n5

     e
     s
     d

### etc/passwd

 man 5 passwd

/etc/passwd (от англ. password — пароль) — файл, содержащий в текстовом формате список пользовательских учётных записей (аккаунтов).

Является первым и основным источником информации о правах пользователя операционной системы. Существует в большинстве версий и вариантов UNIX-систем. Обязан присутствовать в POSIX-совместимой операционной системе.

Шаблон файла 

## login : password : UID : GID : GECOS : home : shell



Каждая строка файла описывает одного пользователя и содержит семь полей, разделённых двоеточиями:

1)регистрационное имя или логин;

2)хеш пароля ;

3)идентификатор пользователя;

4)идентификатор группы по умолчанию

5)информационное поле GECOS ;

6)начальный (он же домашний) каталог;

7)регистрационная оболочка, или shell.


### dev/null
Перенаправление в пустоту

            ls > dev/null
### Перенавправление потоков

\< file - Использовать файл как источник данных для стандартного потока ввода

\> file - Направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху

2\> file - Направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху

\>\>file - Направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец


2\>\>file - Направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец

\&\>file или >&file - Направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >file 2>&1

### WC
Печатает число переводов строк, слов и байт для каждого ФАЙЛА и итоговую строку, если было задано несколько ФАЙЛОВ. Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

c, --bytes
печать числа байтов

-m, --chars
печать числа символов

-l, --lines
печать числа строк

-L, --max-line-length
печать количества символов в самой длинной строке

-w, --words
печать количества слов

--help
вывести справку и закончить работу

--version
вывести информацию о версии и закончить работу


### Примеры использования в совокупности

Записать в файл первые слова из строк с 5 по 17 файла;

    cat file | head -n17 | tail -n+5 > new
    cat new | cut -d' ' -f1

### nl
Печатает каждый ФАЙЛ на стандартный вывод, добавляя номера строк. Если ФАЙЛ не задан или задан как -, читает стандартный ввод

    cat test| nl
     1	sdbfhbsdfb sdnj fb sbhd bf
     2	sdfnk nsdj  dsjfj sj
     3	 sdlf mnksdn ksdf ,lsd
     4	 f

     5	 dsf'
     6	 sdf

     7	 sd
     8	 f
     9	 sd
    10	 f
    11	 sdflpsd
    12	 fsd


    13	 d
    14	 sf
    15	 sd
    16	 f
    17	 sdg
    18	 fdf
    19	 g
    20	 ree

    21	 re

    22	 e
    23	 s
    24	 d
    
    
С опциями 

    cat test| nl -ba
     1	sdbfhbsdfb sdnj fb sbhd bf
     2	sdfnk nsdj  dsjfj sj
     3	 sdlf mnksdn ksdf ,lsd
     4	 f
     5
     6	 dsf'
     7	 sdf
     8
     9	 sd
    10	 f
    11	 sd
    12	 f
    13	 sdflpsd
    14	 fsd
    15
    16
    17	 d
    18	 sf
    19	 sd
    20	 f
    21	 sdg
    22	 fdf
    23	 g
    24	 ree
    25
    26	 re
    27
    28	 e
    29	 s
    30	 d
    31

### tr
tr - выполняет символьное преобразование путём подстановки или удаления символов  

СИНТАКСИС

tr [ОПЦИЯ]... СТРОКА_1 [СТРОКА_2]  

Выполняет преобразование, подстановку (замену), сокращение и/или удаление символов, поступающих со стандартного ввода, записывая результат на стандартное устройство вывода. Она часто применяется для удаления управляющих символов из файла или преобразования регистра символов. Как правило, команде tr передаются две строки (набора) символов: первый набор СТРОКА_1 содержит искомые символы, а второй СТРОКА_2 - те, на которые их следует заменить. При запуске команды устанавливается соответствие между символами обоих наборов, а затем начинается преобразование.

Пример использования:

         cat /etc/bash.bashrc | nl -ba | head -n 17 | tail -n+5 | tr -s ' \t' ':'
            :5:
            :6:#:If:not:running:interactively,:don't:do:anything
            :7:[:-z:"$PS1":]:&&:return
            :8:
            :9:#:check:the:window:size:after:each:command:and,:if:necessary,
            :10:#:update:the:values:of:LINES:and:COLUMNS.
            :11:shopt:-s:checkwinsize
            :12:
            :13:#:set:variable:identifying:the:chroot:you:work:in:(used:in:the:prompt:below)
            :14:if:[:-z:"${debian_chroot:-}":]:&&:[:-r:/etc/debian_chroot:];:then
            :15:debian_chroot=$(cat:/etc/debian_chroot)
            :16:fi
            :17:

### $(...)
 $() конструкция позволяет подставить резултат выполнения программы 
 
 Например:
        
        echo $(ls)
        bin boot cdrom dev etc home initrd.img initrd.img.old lib lib64 lost+found media mnt opt proc root run sbin snap srv sys tmp usr var vmlinuz vmlinuz.old

### tar

   tar позволяет сохранять файлы на архивном носителе (например, дискете или ленте) и восстанавливать их с этого носителя. Действие команды управляется строкой символов, содержащей одну опцию (c, r, t, u или x), и, возможно, один или несколько модификаторов (v, w, f, b, L, k, F, X, h, i, e, n, A, l, m, o, p и num). Остальные аргументы команды - имена файлов (или каталогов), указывающие, какие файлы необходимо заархивировать или извлечь из архива. Во всех случаях указание имени каталога означает ссылку на все файлы и (рекурсивно) подкаталоги этого каталога.

### Команды  для работы с пользователями

1) useradd
    
        man  useradd 
    
    
2) userdel

         man userdel



3) groupadd

         man groupadd

4) passwd
    
          man passwd
5) gpasswd
           
          man grpasswd


### Grep 

Будьте внимательны при использовании в списке_образцов символов $, \*, [, ^, |, (, ) и \, поскольку они являются метасимволами командного интерпретатора. Лучше брать весь список_образцов в одиночные кавычки '... '.

Если имя_файла не указано, grep предполагает поиск в стандартном входном потоке. Обычно каждая найденная строка копируется в стандартный выходной поток. Если поиск осуществлялся в нескольких файлах, перед каждой найденной строкой выдается имя файла.


-b	Предваряет каждую строку номером блока, в котором она была найдена. Это может пригодиться при поиске блоков по контексту (блоки нумеруются с 0).

-c	Выдает только количество строк, содержащих образец.

-h	Предотвращает выдачу имени файла, содержащего сопоставившуюся строку, перед собственно строкой. Используется при поиске по нескольким файлам.

-i	Игнорирует регистр символов при сравнениях.

-l	Выдает только имена файлов, содержащих сопоставившиеся строки, по одному в строке. Если образец найден в нескольких строках файла, имя файла не повторяется.

-n	Выдает перед каждой строкой ее номер в файле (строки нумеруются с 1).

-s	Подавляет выдачу сообщений о не существующих или недоступных для чтения файлах.

-v	Выдает все строки, за исключением содержащих образец.

-w	Ищет выражение как слово, как если бы оно было окружено метасимволами \< и \>.

## Пример:

Задача: имя пользователя +оболочка

         cat etc/passwd | cut -d: -f1,7


$ - конец строки

        cat etc/passwd | grep 'bin/bash$'
        res:
        root:x:0:0:root:/root:/bin/bash
        
 
^ - начало строки

         cat etc/passwd | grep '^system'
         res:
         systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin
         systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin

### etc/shadow



mark:$6$.n.:17736:0:99999:7:::

\[--] [----] \[---] - [---] ----

|      |      |   |   |   |||+-----------> 9. Неиспользованный

|      |      |   |   |   ||+------------> 8. Срок годности

|      |      |   |   |   |+-------------> 7. Период бездействия

|      |      |   |   |   +--------------> 6. Период предупреждения

|      |      |   |   +------------------> 5. Максимальный возраст пароля

|      |      |   +----------------------> 4. Минимальный возраст пароля

|      |      +--------------------------> 3. Последнее изменение пароля

|      +---------------------------------> 2. Зашифрованный пароль

+----------------------------------------> 1. Имя пользователя


Как и в файле passwd, каждое поле в файле shadow отделяется двоеточием:

1)Username, до 8 символов. Совпадает с username в файле /etc/passwd.

2)Пароль, 13 символов (зашифрованный). Пустая запись (то есть, ::) показывает, что для входа пароль не нужен (обычно идея плохая), и запись 
(то есть, :*:) показывает, что вход заблокирован.

3)Количество дней (с 1 января 1970), когда пароль был сменен в последний раз.

4)Число дней до смены пароля (0 показывает, что он может быть сменен всегда).

5)Число дней, после которых пароль должен быть сменен (99999 показывает, что пользователь может не менять пароль фактически никогда).

6)Число дней, в течение которых пользователь получает предупреждения о необходимости пароль сменить (7 для полной недели).

7)Число дней после окончания действия пароля, когда еще можно работать. Если пароль не сменить, после данного срока он выдохнется, и аккаунт будет заблокирован.

8)Число дней, начиная с 1 января 1970, после которых пароль будет заблокирован.

9)Зарезервировано для возможного будущего использования.
