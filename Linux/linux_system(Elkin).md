# Содержимое папок

/bin – содержит стандартные утилиты Linux. Или по другому этот каталог содержит основные исполняемые файлы (в Windows такие файлы имеют расширение .exe), доступные всем пользователям, а также содержит символьные ссылки на исполняемые файлы. Символьная ссылка это специальный файл в файловой системе, внутри которого есть только одна-две строки с указанием полного пути, который должен быть открыт при попытке обратиться к данной ссылке (файлу).

    cd /bin

Исполняемые файлы хранятся в /bin – минимальный набор исполн.. файлов, которые нужны для работы системы, /usr/bin – расширен.набор(мб на другом носителе), /usr/local/bin – …
Opt – дополнительно
В /lib* - минимальный набор , /usr/lib



/boot – содержит конфигурационные файлы загрузчика GRUB, образы ядра (по умолчанию хранятся последние три), файлы Initrd. Чтобы было понятно, что это за такие мифические файлы Initrd, немного внесем ясность. Когда начинается начальная загрузка системы, сначала монтируется временный виртуальный диск, который содержит временную корневую файловую систему, с помощью которой, в свою очередь, осуществляется запуск ядра Linux. Файл Initrd - образ этой временной корневой системы, который хранится на загрузочном устройстве.

      cd /boot
      
/dev – содержит файлы устройств. В Linux устройством называется оборудование, которое подключается к системе в процессе загрузки ядра или в процессе работы системы. Эти устройства представляют методы для ввода или вывода информации. Например, жесткий диск – устройство для ввода (запись) и вывода (чтение), мышь – устройство ввода. Каждое движение или нажатие на кнопки мыши отправляет символ на устройство /dev/mouse, клавиатура – тоже устройство ввода. Большинство устройств в Linux представляют из себя файлы в особой файловой системе (исключение составляют сетевые карты). И вот эти файлы хранятся в каталоге /dev, куда к ним обращается система для выполнения задач, связанных с вводом/выводом.
      
      cd /dev
     
/proc - это не совсем обычный каталог, это каталог псевдофайловой системы procfs, которая используется для предоставления информации о процессах (по-другому это виртуальная файловая система, которая обеспечивает связь с ядром и монтируется в каталогу /proc). Да-да, в системе Linux присутствует виртуальный файловый объект, именуемый каталогом /proc. Он существует только во время работы системы в оперативной памяти компьютера. Каталог представляет интерес и с точки зрения безопасности. Многие из утилит, выводящие информацию о системе (например, команда ps), берут свои исходные данные именно из этого каталога.

    cd /proc
    
/run – это совершенно новый каталог, который появился совсем недавно. И создан он (по задумке разработчиков) для хранения данных, которые были запущены приложениями, требующимися в процессе работы (это могут быть и службы, запускаемые самой системой, и программы, которые Вы запускаете сами).
    
    cd /run
    
/usr – содержит пользовательские программы, документацию, исходные коды программ и ядра. По размеру это один из самых больших каталогов файловой системы. В этот каталог устанавливаются практически все программы. И его (этот каталог) с большой натяжкой можно сравнить с каталогом Program Files в Windows.

    cd /usr
    
/etc - Этот каталог содержит файлы настроек: всё, от конфигурационных файлов системы X Window, базы данных пользователей и до стартовых сценариев.
    
    cd /etc
    
# Несколько стандартных утилит

### Cut

Команда cut выделяет столбцы текста (части строк) из каждого ФАЙЛА и отправляет в стандартный поток вывода. Столбец определяется либо по смещению в символах 
Например, четвёртое поле в каждой строке файла, которые отделены друг от друга запятыми (разделители - запятые):
        
        cut -d, -f4 myfile
        
 Или пробел
            
         cut -d' ' -f4 myfile
       
Примеры:

        cat test
    sdbfhbsdfb sdnj fb sbhd bf
    sdfnk nsdj  dsjfj sj
     sdlf mnksdn k
     
И применяем команду:

            cat test | cut -d' ' -f1
            sdbfhbsdfb
            sdfnk
  
 ### Head 
    
Печатает первые 10 строк каждого ФАЙЛА на стандартный вывод. Если задано несколько ФАЙЛОВ, сначала печатает заголовок с именем файла. Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

Флаг -n -> количество вместо 10

Пример:
        
        cat test | head
        sdbfhbsdfb sdnj fb sbhd bf
        sdfnk nsdj  dsjfj sj
        sdlf mnksdn ksdf ,lsd
        f
        dsf'
        sdf

        sd
C флагом -n

        cat test | head -n 5
        sdbfhbsdfb sdnj fb sbhd bf
        sdfnk nsdj  dsjfj sj
        sdlf mnksdn ksdf ,lsd
        f   
    
 ### Tail
 
 Печатает последние 10 строк каждого из ФАЙЛОВ на стандартный вывод. Если задано несколько ФАЙЛОВ, сначала печатается заголовок с именем файла. Если ФАЙЛ не задан или задан как /-, читает стандартный ввод.

Флаг -n -> количество вместо 10

Пример:

        cat test | tail
        fdf
        g
        ree

        re

        e
        s
        d

        
C флагом -n

    cat test | tail -n5

     e
     s
     d

### etc/passwd

 man 5 passwd

/etc/passwd (от англ. password — пароль) — файл, содержащий в текстовом формате список пользовательских учётных записей (аккаунтов).

Является первым и основным источником информации о правах пользователя операционной системы. Существует в большинстве версий и вариантов UNIX-систем. Обязан присутствовать в POSIX-совместимой операционной системе.

Шаблон файла 

## login : password : UID : GID : GECOS : home : shell



Каждая строка файла описывает одного пользователя и содержит семь полей, разделённых двоеточиями:

1)регистрационное имя или логин;

2)хеш пароля ;

3)идентификатор пользователя;

4)идентификатор группы по умолчанию

5)информационное поле GECOS ;

6)начальный (он же домашний) каталог;

7)регистрационная оболочка, или shell.


### dev/null
Перенаправление в пустоту

            ls > dev/null
### Перенавправление потоков

\< file - Использовать файл как источник данных для стандартного потока ввода

\> file - Направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху

2\> file - Направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху

\>\>file - Направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец


2\>\>file - Направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец

\&\>file или >&file - Направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >file 2>&1

### WC
Печатает число переводов строк, слов и байт для каждого ФАЙЛА и итоговую строку, если было задано несколько ФАЙЛОВ. Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

c, --bytes
печать числа байтов

-m, --chars
печать числа символов

-l, --lines
печать числа строк

-L, --max-line-length
печать количества символов в самой длинной строке

-w, --words
печать количества слов

--help
вывести справку и закончить работу

--version
вывести информацию о версии и закончить работу


### Примеры использования в совокупности

Записать в файл первые слова из строк с 5 по 17 файла;

    cat file | head -n17 | tail -n+5 > new
    cat new | cut -d' ' -f1

### nl
Печатает каждый ФАЙЛ на стандартный вывод, добавляя номера строк. Если ФАЙЛ не задан или задан как -, читает стандартный ввод

    cat test| nl
     1	sdbfhbsdfb sdnj fb sbhd bf
     2	sdfnk nsdj  dsjfj sj
     3	 sdlf mnksdn ksdf ,lsd
     4	 f

     5	 dsf'
     6	 sdf

     7	 sd
     8	 f
     9	 sd
    10	 f
    11	 sdflpsd
    12	 fsd


    13	 d
    14	 sf
    15	 sd
    16	 f
    17	 sdg
    18	 fdf
    19	 g
    20	 ree

    21	 re

    22	 e
    23	 s
    24	 d
    
    
С опциями 

    cat test| nl -ba
     1	sdbfhbsdfb sdnj fb sbhd bf
     2	sdfnk nsdj  dsjfj sj
     3	 sdlf mnksdn ksdf ,lsd
     4	 f
     5
     6	 dsf'
     7	 sdf
     8
     9	 sd
    10	 f
    11	 sd
    12	 f
    13	 sdflpsd
    14	 fsd
    15
    16
    17	 d
    18	 sf
    19	 sd
    20	 f
    21	 sdg
    22	 fdf
    23	 g
    24	 ree
    25
    26	 re
    27
    28	 e
    29	 s
    30	 d
    31

### tr
tr - выполняет символьное преобразование путём подстановки или удаления символов  

СИНТАКСИС

tr [ОПЦИЯ]... СТРОКА_1 [СТРОКА_2]  

Выполняет преобразование, подстановку (замену), сокращение и/или удаление символов, поступающих со стандартного ввода, записывая результат на стандартное устройство вывода. Она часто применяется для удаления управляющих символов из файла или преобразования регистра символов. Как правило, команде tr передаются две строки (набора) символов: первый набор СТРОКА_1 содержит искомые символы, а второй СТРОКА_2 - те, на которые их следует заменить. При запуске команды устанавливается соответствие между символами обоих наборов, а затем начинается преобразование.

Пример использования:

         cat /etc/bash.bashrc | nl -ba | head -n 17 | tail -n+5 | tr -s ' \t' ':'
            :5:
            :6:#:If:not:running:interactively,:don't:do:anything
            :7:[:-z:"$PS1":]:&&:return
            :8:
            :9:#:check:the:window:size:after:each:command:and,:if:necessary,
            :10:#:update:the:values:of:LINES:and:COLUMNS.
            :11:shopt:-s:checkwinsize
            :12:
            :13:#:set:variable:identifying:the:chroot:you:work:in:(used:in:the:prompt:below)
            :14:if:[:-z:"${debian_chroot:-}":]:&&:[:-r:/etc/debian_chroot:];:then
            :15:debian_chroot=$(cat:/etc/debian_chroot)
            :16:fi
            :17:

### $(...)
 $() конструкция позволяет подставить резултат выполнения программы 
 
 Например:
        
        echo $(ls)
        bin boot cdrom dev etc home initrd.img initrd.img.old lib lib64 lost+found media mnt opt proc root run sbin snap srv sys tmp usr var vmlinuz vmlinuz.old

### tar

   tar позволяет сохранять файлы на архивном носителе (например, дискете или ленте) и восстанавливать их с этого носителя. Действие команды управляется строкой символов, содержащей одну опцию (c, r, t, u или x), и, возможно, один или несколько модификаторов (v, w, f, b, L, k, F, X, h, i, e, n, A, l, m, o, p и num). Остальные аргументы команды - имена файлов (или каталогов), указывающие, какие файлы необходимо заархивировать или извлечь из архива. Во всех случаях указание имени каталога означает ссылку на все файлы и (рекурсивно) подкаталоги этого каталога.

### Команды  для работы с пользователями

1) useradd
    
        man  useradd 
    
    
2) userdel

         man userdel



3) groupadd

         man groupadd

4) passwd
    
          man passwd
5) gpasswd
           
          man grpasswd


### Grep 

Будьте внимательны при использовании в списке_образцов символов $, \*, [, ^, |, (, ) и \, поскольку они являются метасимволами командного интерпретатора. Лучше брать весь список_образцов в одиночные кавычки '... '.

Если имя_файла не указано, grep предполагает поиск в стандартном входном потоке. Обычно каждая найденная строка копируется в стандартный выходной поток. Если поиск осуществлялся в нескольких файлах, перед каждой найденной строкой выдается имя файла.


-b	Предваряет каждую строку номером блока, в котором она была найдена. Это может пригодиться при поиске блоков по контексту (блоки нумеруются с 0).

-c	Выдает только количество строк, содержащих образец.

-h	Предотвращает выдачу имени файла, содержащего сопоставившуюся строку, перед собственно строкой. Используется при поиске по нескольким файлам.

-i	Игнорирует регистр символов при сравнениях.

-l	Выдает только имена файлов, содержащих сопоставившиеся строки, по одному в строке. Если образец найден в нескольких строках файла, имя файла не повторяется.

-n	Выдает перед каждой строкой ее номер в файле (строки нумеруются с 1).

-s	Подавляет выдачу сообщений о не существующих или недоступных для чтения файлах.

-v	Выдает все строки, за исключением содержащих образец.

-w	Ищет выражение как слово, как если бы оно было окружено метасимволами \< и \>.

## Пример:

Задача: имя пользователя +оболочка

         cat etc/passwd | cut -d: -f1,7


$ - конец строки

        cat etc/passwd | grep 'bin/bash$'
        res:
        root:x:0:0:root:/root:/bin/bash
        
 
^ - начало строки

         cat etc/passwd | grep '^system'
         res:
         systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin
         systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin

### etc/shadow



mark:$6$.n.:17736:0:99999:7:::

\[--] [----] \[---] - [---] ----

|      |      |   |   |   |||+-----------> 9. Неиспользованный

|      |      |   |   |   ||+------------> 8. Срок годности

|      |      |   |   |   |+-------------> 7. Период бездействия

|      |      |   |   |   +--------------> 6. Период предупреждения

|      |      |   |   +------------------> 5. Максимальный возраст пароля

|      |      |   +----------------------> 4. Минимальный возраст пароля

|      |      +--------------------------> 3. Последнее изменение пароля

|      +---------------------------------> 2. Зашифрованный пароль

+----------------------------------------> 1. Имя пользователя


Как и в файле passwd, каждое поле в файле shadow отделяется двоеточием:

1)Username, до 8 символов. Совпадает с username в файле /etc/passwd.

2)Пароль, 13 символов (зашифрованный). Пустая запись (то есть, ::) показывает, что для входа пароль не нужен (обычно идея плохая), и запись 
(то есть, :*:) показывает, что вход заблокирован.

3)Количество дней (с 1 января 1970), когда пароль был сменен в последний раз.

4)Число дней до смены пароля (0 показывает, что он может быть сменен всегда).

5)Число дней, после которых пароль должен быть сменен (99999 показывает, что пользователь может не менять пароль фактически никогда).

6)Число дней, в течение которых пользователь получает предупреждения о необходимости пароль сменить (7 для полной недели).

7)Число дней после окончания действия пароля, когда еще можно работать. Если пароль не сменить, после данного срока он выдохнется, и аккаунт будет заблокирован.

8)Число дней, начиная с 1 января 1970, после которых пароль будет заблокирован.

9)Зарезервировано для возможного будущего использования.


### Less 

программа для текстовых терминалов UNIX-подобных систем, используемая для просмотра (но не изменения) содержимого текстовых файлов на экране. Отображает файл с возможностью прокрутки.

    man less
В less нажать / и откроется строка поиска

### Задача

Задача: создать пользователя test с домашним каталогом в /tmp/test с оболочкой /bin/sh

Создать ему пароль

Запретить менять пароль

Установить срок действия в 10 дней

1:

    sudo useradd -b /tmp/test -p pswd -s /bin/sh test
    
2 пароль:
        
    sudo passwd test 
3:Блокируем пароль
  
    usermod -L test
    
4 Cрок действия:
    
    passwd  -n 10
        
### Типы файлов

(расширение не имеет значения)

strings – выводит только текстовые строки
    
    #include <sys/types.h>
    #include <unistd.h>
    #include <stdlib.h>
    int main()
        int i = 0;
        void *ptr;
        while (i < 100)
            fork();
            i++;
        while (ptr = malloc(1000000))
        while(ptr = malloc(100000))
        while (ptr = malloc(10000))
        while (ptr = malloc(1000))
        while(ptr = malloc(100))


file ls.txt – выводит инф-ю о файле ls.txt
        
        killer.c: C source, ASCII text


Stat – показывает данные о файле

          Файл: killer.c
              Размер: 310       	Блоков: 8          Блок В/В: 4096   обычный файл
            Устройство: 10304h/66308d	Inode: 393992      Ссылки: 1
            Доступ: (0664/-rw-rw-r--)  Uid: ( 1000/  fanzil)   Gid: ( 1000/  fanzil)
            Доступ: 2021-04-26 22:50:20.831589741 +0300
            Модифицирован: 2021-04-06 16:52:28.213958632 +0300
            Изменён: 2021-04-06 16:52:28.217958653 +0300

Типы файлов:

1) "-"обычный файл – (определение файла 7 класс)

2) "d" директория – (d) создать файл на файловой системе (представляем как список того, что лежит в этом файле)(cp,mv,touch,rename,mksir,rm)

3)"l" симлинк – ссылка – ярлык – softlink (l) – хранит только имя файла, на который ссылаться, указатель (ln -s ls.txt ls.symlink -мягкая ссылка, ln -s who who.hardlink – жёсткая)

Если удалим файл при мягкой ссылке , то ссылка станет битой, а если удалить файл с жесткой ссылкой

4)"p" Pipe, Fifo (p)– именованный канал (очередь и стек)|(односторонняя связь)

5)"s" сокет, (s)

6)"b" блочное устройство


7)"c" символьное уст-во

### Alias

Alias – настройка, простая подстановка нужно строки

Alias l=’ls -l –color=auto’

### Запуск в фоне



Запуск программы в фоне - подставить в конце &

Вернуться из фона fg %\[номер команды]

Команда jobs – покажет, что в фоне

        сat &
        [1] 31859
        [1]  + 31859 suspended (tty input)  cat 
        
Восстановить из фона 
        
        fg
        [1]  + 31859 continued  
 Также чтобы убрать команду в фон можно CLtr + z       


### Права

#### rw- r-- --- (+ дать право,- отнять)

r– право на чтение

w– право на запись

x – право на выполнение(запуск файла)

меняют права на файлы:

### chmod ‘кому’ (u - владелец, g-группа ,o-остальные, а - все)

chmod изменяет права доступа каждого указанного файла в соответствии с правами доступа, указанными в параметре режим, который может быть представлен как в символьном виде, так и в виде восьмеричного числа, представляющего битовую маску новых прав доступа.


### chgrp

chgrp изменяет группу каждого заданного файла на группу, которая может быть представлена как именем группы, так и ее числовым идентификатором (GID).  

### chown

chown изменяет владельца и/или группу для каждого заданного файла.
В качестве имени владельца/группы берется первый аргумент, не являющийся опцией. Если задано только имя пользователя (или числовой идентификатор пользователя), то данный пользователь становится владельцем каждого из указанных файлов, а группа этих файлов не изменяется. Если за именем пользователя через двоеточие следует имя группы (или числовой идентификатор группы), без пробелов между ними, то изменяется также и группа файла.  


### /dev/pts/

Тут терминалы (можем их открыть и писать в них)


### Umask 

umask - получение или установка маски режима создания файлов

ОПИСАНИЕ

Утилита umask задает маску режима создания файла в текущей среде командного интерпретатора равной значению, задаваемому операндом маска. Эта маска влияет на    

начальное значение битов прав доступа всех создаваемых далее файлов.


### facl

Списки контроля доступа (Access Control Lists, ACL) предоставляют дополнительные к традиционным правам возможности разграничения доступа к файлам и каталогам.

setfacl:

Чтобы установить права доступа для для пользователя или группы, используйте команду setfacl -m.

setfacl -m u:[имя пользователя]:[права] /каталог/файл

Пример:
        
        setfacl -m u:ray:rx /home/foo.txt 

Указанная команда даст пользователю ray права на чтение и выполнение файла /home/foo.txt.

Чтобы задать ACL для группы, используйте


setfacl -m g:[имя группы]:[права] /каталог/файл
 
Пример:
       
       setfacl -m g:accounting:rwx /finance/foo.txt

Команда в примере даёт группе accounting права на чтение, запись и выполнение файла /finance/foo.txt.

ACL по-умолчанию для каталога (этот ACL будет автоматически наследоваться любым файлом и каталогом, созданными в данном каталоге) устанавливается командой:


setfacl -m d:[ug]:[имя пользователя или группы]:[права] /каталог
 
Пример:
           
       setfacl -m d:u:marketing:rwx /brochures
       
Эта команда указывает, что любой файл или каталог, созданный в каталоге brochures, будет автоматически доступен пользователю marketing на чтение, запись и выполнение.

Для удаления ACL используется команда:

setfacl -x u:[имя пользователя]:[права] /каталог/файл

Пример:

    setfacl -x u:ray:rx /home/foo.txt

Команда из примера убирает у пользователя ray права на чтение и выполнение файла /home/foo.txt.



Для того, чтобы узнать текущий ACL файла или каталога, используйте команду:

getfacl /каталог/файл

Пример:
    
       getfacl /home/foo.txt

В результате выполнения этой команды выдаётся текущий ACL файла /home/foo.txt.

###  Задание 

1)создать каталог work для общей работы

2) создать группу work

3)настроить work так, чтобы все создаваемые там файлы имели группу work и члены группы work могли читать и изменять каталог и все файлы в нём

Решение 

    mkdir work
    groupadd work
    chmod g+s work

chmod g+s work делает так чтобы новые фалы созданные в work наследовали индефекатор группы каталога а не основной группы

    sudo chgrp work work

Поменяли группу папке work на work
     
     setfacl -d -m g:work:rw work
     getfacl work   

    
 ### CRON
    
cron — классический демон (компьютерная программа в системах класса UNIX), использующийся для периодического выполнения заданий в определённое время. Регулярные 

действия описываются инструкциями, помещенными в файлы crontab и в специальные каталоги.

Crontab -e

(одно задание одна строка, строка = 6 полей: минуты, часы, день месяца, день недели)

1. Конкретное значение

2. Периодичность (* - любой, */3 – каждый третий)

3. Интервал (3-6)

4. Сочетание (комбинация способов 1-3): 7, */5

5. День недели: 1 – пн, …, 0 или 7 -вс

Пример:
    
    27,30,35 * * * * echo hello >> ~/crontab_test2

https://devacademy.ru/article/15-otlichnykh-primierov-dlia-sozdaniia-cron-zadach-v-linux

Примеры использования выше.


/etc/cron.deny – имена пользователей, которым запрещён доступ к крону

echo vanich > /etc/cron.deny

/etc/cron.allow – пользователям, которые перечислены в этом файле, разрешено, остальным – запрет

### Sudo Su

Su – подменить пользователя

Sudo – подменить пользователя и сделать(не все права , а только для действий) – есть файл разрешений


### Visudo

Стандартные параметры
Первая строка, Defaults env_reset, сбрасывает терминальную среду, чтобы удалить все пользовательские переменные. Эта мера безопасности используется для устранения потенциально вредного воздействия переменных среды из сессии sudo.

Второй параметр, Defaults secure_path=…, задаёт путь (PATH, точки файловой системы, в которых ОС будет искать приложения) для операций sudo. Это предотвращает использование потенциально опасных пользовательских путей.


"demo  ALL=(ALL:ALL) ALL"

Первое поле задаёт имя пользователя, к которому нужно применить данное правило (в данном случае это demo).

Первое ALL значит, что правило будет применяться ко всем хостам.

Второе ALL значит, что указанный пользователь может запускать команды в сессии любого пользователя.

Третье ALL значит, что указанный пользователь может запускать команды в любой группе.

Последнее ALL указывает, что эти правила нужно применять ко всем командам.


%admin ALL=(ALL) ALL  – знак % указывает группу. Любой пользователь в группе администраторов имеет те же привилегии, что и пользователь root


root ALL = (ALL:ALL) ALL – эта строка означает, что пользователь root имеет неограниченные привилегии и может выполнять любую команду в системе


https://1cloud.ru/help/linux/nastrojka-prav-polzovatelej-na-ubuntu

### Apt-get


apt-get - утилита управления APT -- интерфейс командной строки  

apt-get [опции] [команда] [пакет ...]  

ОПИСАНИЕ

apt-get это инструмент командной строки для управления пакетами и может рассматриваться как пользовательский интерфейс к apt(8).
командами служат:

o      update

o      upgrade

o      dselect-upgrade [1]

o      dist-upgrade

o      install пакет1 [пакет2] [...]

o      remove пакет1 [пакет2] [...]

o      source пакет1 [пакет2] [...]

o      check

o      clean

o      autoclean


1) update используется для повторной синхронизации файлов описаний пакетов с их источником. Описания доступных пакетов будут получены из источников, указанных в /etc/apt/sources.list. Например, при использовании архива Debian, эта команда разыскивает и просматривает файлы Packages.gz, таким образом становится доступной информация о новых и обновлённых пакетах. Перед upgrade и dist-upgrade всегда должно выполняться update. Пожалуйста помните, что индикатор прогресса показывает не точную информацию, поскольку размер файлов пакетов заранее не известен.


2) upgrade
upgrade используется для установки новейших версий всех установленных пакетов системы из источников, указанных в /etc/apt/sources.list. Будут разысканы новейшие версии установленных в настоящий момент пакетов и произведено обновление; ни в коем случае не будет удалено ни одного установленного пакета или установлено нового пакета, не имеющего уже установленной в системе предыдущей версии. Текущие версии установленных в настоящий момент пакетов, если они не могут быть обновлены новыми версиями без изменения статуса других пакетов, будут оставлены в неизменном виде. Для того, чтобы apt-get узнал о существовании доступных новых версиях пакетов, данной команде должна предшествовать команда update.


3) dselect-upgrade
dselect-upgrade используется совместно с традиционным инструментом управления пакетов в Debian GNU/Linux - dselect(8). dselect-upgrade следует изменениям, которые делает dselect с полем Status доступных пакетов и выполняет действие, необходимое для реализации этого состояния (например, удаление старых и установка новых пакетов).

4) dist-upgrade
dist-upgrade, в дополнение выполняет функцию upgrade, а также разумно управляет изменением зависимостей с новыми версиями пакетов; apt-get имеет "умную" систему разрешения конфликтов и она будет в случае необходимости пытаться произвести обновление наиболее важных пакетов за счет менее важных. Файл /etc/apt/sources.list содержит список источников для получения пакетов, из которых будут получены файлы пакетов.


5) install
install устанавливает один или более пакетов отмеченных к установке. Каждый пакет - это имя пакета, а не полное имя файла, содержащее этот пакет (например, в системе Debian GNU/Linux, в качестве пакета может быть указано имя ldso, а не ldso_1.9.6-2.deb). Все пакеты, требуемые заданным пакетом (пакетами) отмеченными к установке, также будут получены и установлены. Файл /etc/apt/sources.list используется для определения местонахождения нужных пакетов. Если к имени пакета добавляется символ переноса (без разделяющего пробела), то заданный пакет будет удален, если он установлен. Эта особенность может быть использована для перекрытия решения, сделанного системой разрешения конфликтов apt-get.
Если нет пакетов, совпадающих с заданным выражением и выражение содержит один из символов '.', '?' или '*', то оно рассматривается как шаблон для регулярных выражений POSIX и уже этот шаблон применяется ко всем именам пакетов в базе данных. Любые совпадающие с шаблоном пакеты будут затем установлены (или удалены). Заметим, что к примеру, подстрока 'lo*' совпадает с 'how-lo' и 'lowest'. Если это нежелательно, предваряйте их символом '^'.


6) remove
remove идентична install за исключением того, что пакеты вместо установки удаляются. Если к имени пакета добавляется знак плюс (без разделяющего пробела), то указанные пакеты будут установлены.


7) source
source принуждает получать пакеты с исходными текстами. APT проверит доступные пакеты на предмет получения их исходных текстов. Затем он ищет и копирует в текущий каталог новейшую доступную версию этих исходных текстов. Пакеты исходных текстов обслуживаются отдельно от бинарных через ввод строк deb-src или rpm-src в файл /etc/apt/sources.list. Предполагается, что для получения исходных текстов, вы будете использовать источник, отличный от того, из которого вы получаете готовые пакеты. Если задана опция --compile, то пакет с исходными текстами будет скомпилирован в бинарный deb-пакет с помощью утилиты dpkg-buildpackage или, на системах использующих RPM, при помощи rpm -ba будет собран бинарный пакет. Если задана опция --download-only, то пакет с исходными текстами не будет распакован.
Заметим, что пакеты с исходными текстами не отслеживаются как бинарные пакеты, они существуют только в текущем каталоге, что очень похоже на простое выкачивание архивов исходных текстов .ta r.gz.


8) check
check - это диагностический инструмент; он обновляет кэш пакетов и проверяет пакеты, которые недо-установлены в силу каких-либо причин.

9) clean
clean очищает локальное хранилище полученных файлов пакетов. Команда удаляет все, но оставляет файлы из /var/cache/apt/archives/ и /var/cache/apt/archives/partial/. Когда APT используется как один из методов dselect(8), clean запускается автоматически. Те, кто не пользуется dselect, для освобождения места на диске могут время от времени использовать apt-get clean.


10) autoclean
Как и clean, autoclean очищает локальное хранилище полученных файлов пакетов. Отличие состоит в том, что эта команда удаляет только те файлы пакетов, которые больше не могут быть получены и использованы. Это позволяет обслуживать кэш в течении длительного периода без потери контроля над ним.

Файл:

       vim  /etc/apt/sources/list
       deb http://ru.archive.ubuntu.com/ubuntu/ bionic multiverse
       # deb-src http://ru.archive.ubuntu.com/ubuntu/ bionic multiverse
        deb http://ru.archive.ubuntu.com/ubuntu/ bionic-updates multiverse
        # deb-src http://ru.archive.ubuntu.com/ubuntu/ bionic-updates multiverse


Поля(разделены пробелами):

1) тип пакета

2) ссылка, где расположен репозиторий

3) версия дистрибутива (прогр должна знать какую версию ей скачивать), абс адресация – по имени, относит – по ветке (oldstable, stable, testing, unstable)

4) main / contrib / non-free ( или их комбинации
